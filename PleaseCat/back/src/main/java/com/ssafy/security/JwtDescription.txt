참고: https://daddyprogrammer.org/post/636/springboot2-springsecurity-authentication-authorization/

 1) [ SpringSecurity ]

	스프링에서는 인증 및 권한 부여를 통해 리소스의 사용을 쉽게 컨트롤할 수 있는 
	SpringSecurity framework를 제공하고 있습니다. 
	
	Spring boot기반의 프로젝트에 SpringSecurity를 적용하면 
	보안 관련 처리를 자체적으로 구현할 필요 없이 쉽게 필요한 기능을 구현할 수 있습니다. 
	
	간략하게 아래의 그림처럼 SpringSecurity는 Spring의 DispatcherServlet 앞단에
	 Filter를 등록시켜 요청을 가로챕니다. 
	 
	 클라이언트에게 리소스 접근 권한이 없을 경우엔 인증(ex:로그인) 화면으로 자동으로 리다이렉트 합니다.
 
 
 2) [ SpringSecurity Filter ]

	SpringSecurity는 기능별 필터의 집합으로 되어있고 필터의 처리 순서는 아래와 같습니다. 
	종류가 매우 많지만 여기서 중요한 것은 필터의 처리 순서입니다. 
	
	클라이언트가 리소스를 요청할 때 접근 권한이 없는 경우 기본적으로 로그인 폼으로 보내게 되는데 
	그 역할을 하는 필터는 UsernamePasswordAuthenticationFilter입니다.
	
	Rest Api에서는 로그인 폼이 따로 없으므로 인증 권한이 없다는 오류 Json을 내려줘야 하므로
	UsernamePasswordAuthenticationFilter 전에 관련 처리를 넣어야 함을 알 수 있습니다.


 3) [ API 인증 및 권한 부여, 제한된 리소스의 요청 ]
 
	인증을 위해 가입(Signup)및 로그인(Signin) api를 구현합니다.
	가입 시 제한된 리소스에 접근할 수 있는 ROLE_USER 권한을 회원에게 부여합니다.
	
	SpringSecurity 설정에는 접근 제한이 필요한 리소스에 대해서 ROLE_USER 권한을 가져야 접근 가능하도록 세팅합니다.
	권한을 가진 회원이 로그인 성공 시엔 리소스에 접근할 수 있는 Jwt 보안 토큰을 발급합니다.
	Jwt 보안 토큰으로 회원은 권한이 필요한 api 리소스를 요청하여 사용합니다.
	
	
 4) [ JWT 란? ]
 
	JSON Web Token (JWT)은 JSON 객체로서 당사자간에 안전하게 정보를 전송할 수 있는 
	작고 독립적인 방법을 정의하는 공개 표준 (RFC 7519)입니다. 
	자세한 내용은 아래 링크에서 확인할 수 있습니다.
	
	https://jwt.io/introduction/
	Jwt는 JSON 객체를 암호화하여 만든 String값으로 기본적으로 암호화되어있어 변조하기가 어려운 정보입니다. 
	또한 다른 토큰과 달리 토큰 자체에 데이터를 가지고 있습니다. 
	
	api 서버에서는 로그인이 완료된 클라이언트에게 회원을 구분할 수 있는 값을 넣은 Jwt 토큰을 생성하여 발급하고, 
	클라이언트는 이 Jwt 토큰을 이용하여 권한이 필요한 리소스를 서버에 요청하는 데 사용할 수 있습니다. 
	
	api서버는 클라이언트에게서 전달받은 Jwt 토큰이 유효한지 확인하고 담겨있는 회원 정보를 확인하여 
	제한된 리소스를 제공하는데 이용할 수 있습니다.	
	
	
 5) [ build.gradle에 library 추가 ]
 
	SpringSecurity 및 Jwt관련 라이브러리를 build.gradle에 추가합니다.
	
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'io.jsonwebtoken:jjwt:0.9.1'	
	
	
 6) [ JwtTokenProvider 생성 ]
 
	Jwt 토큰 생성 및 유효성 검증을 하는 컴포넌트입니다. 
	Jwt는 여러 가지 암호화 알고리즘을 제공하며 
	알고리즘(SignatureAlgorithm.XXXXX)과 비밀키(secretKey)를 
	가지고 토큰을 생성하게 됩니다. 
	
	이때 claim정보에는 토큰에 부가적으로 실어 보낼 정보를 세팅할 수 있습니다. 
	
	claim 정보에 회원을 구분할 수 있는 값을 세팅하였다가 토큰이 들어오면 해당 값으로 
	회원을 구분하여 리소스를 제공하면 됩니다. 
	그리고 Jwt토큰에는 expire 시간을 세팅할 수 있습니다. 
	
	토큰 발급 후 일정 시간 이후에는 토큰을 만료시키는 데 사용할 수 있습니다. 
	resolveToken 메서드는 Http request header에 세팅된 토큰 값을 가져와 유효성을 체크합니다. 
	제한된 리소스를 요청할 때 Http header에 토큰을 세팅하여 호출하면 유효성을 검증하여 사용자 인증을 할 수 있습니다.	


 7) [ JwtAuthenticationFilter 생성 ]
 
	Jwt가 유효한 토큰인지 인증하기 위한 Filter입니다. 
	com.rest.api.config.security 하위에 Class를 생성합니다. 
	이 필터는 Security 설정 시 UsernamePasswordAuthenticationFilter앞에 세팅할 것입니다.


 8) [ SpringSecurity Configuration ]
 
	서버에 보안 설정을 적용합니다. com.rest.api.config.security 하위에 다음 Class를 작성합니다. 
	아무나 접근 가능한 리소스는 permitAll()로 세팅하고 나머지 리소스는 
	다음과 같이 ‘ROLE_USER’ 권한이 필요함으로 명시합니다. 
	
	anyRequest().hasRole(“USER”) 또는 anyRequest().authenticated()는 동일한 동작을 합니다.
	위에서 설명했듯이 해당 filter는 UsernamePasswordAuthenticationFilter 앞에 설정해야 합니다. 
	SpringSecurity 적용 후에는 모든 리소스에 대한 접근이 제한되므로. 
	Swagger 페이지에 대해서는 예외를 적용해야 페이지에 접근할 수 있습니다. 
	리소스 접근 제한 표현식은 여러 가지가 있으며 다음과 같습니다.
	
	hasIpAddress(ip) : 접근자의 IP주소가 매칭 하는지 확인합니다.        
	hasRole(role) : 역할이 부여된 권한(Granted Authority)과 일치하는지 확인합니다.        
	hasAnyRole(role) : 부여된 역할 중 일치하는 항목이 있는지 확인합니다.                          
	예 – access = “hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”        
	permitAll : 모든 접근자를 항상 승인합니다.        
	denyAll : 모든 사용자의 접근을 거부합니다.        
	anonymous : 사용자가 익명 사용자인지 확인합니다.        
	authenticated : 인증된 사용자인지 확인합니다.        
	rememberMe : 사용자가 remember me를 사용해 인증했는지 확인합니다.        
	fullyAuthenticated : 사용자가 모든 크리덴셜을 갖춘 상태에서 인증했는지 확인합니다.	
	

 9) [ Custom UserDetailsService 정의 ]

	토큰에 세팅된 유저 정보로 회원정보를 조회하는 UserDetailsService를 재정의 합니다.	
	
10) [ User Entity 수정 ]
	SpringSecurity의 보안을 적용하기 위해 User entity에 UserDetails Class를 
	상속받아 추가 정보를 재정의 합니다. roles는 회원이 가지고 있는 권한 정보이고, 
	가입했을 때는 기본 “ROLE_USER”가 세팅됩니다. 권한은 회원당 여러 개가 세팅될 수 있으므로 
	Collection으로 선언합니다.
	
	getUsername은 security에서 사용하는 회원 구분 id입니다. 여기선 uid로 변경합니다.
	다음 값들은 Security에서 사용하는 회원 상태 값입니다. 여기선 모두 사용 안 하므로 true로 설정합니다.
	Json결과로 출력 안 할 데이터는 @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) 
	어노테이션을 선언해줍니다.
	
	isAccountNonExpired : 계정이 만료가 안되었는지
	isAccountNonLocked : 계정이 잠기지 않았는지
	isCredentialsNonExpired : 계정 패스워드가 만료 안됬는지
	isEnabled : 계정이 사용 가능한지	
	

 11) [ UserJpaRepo에 findByUid추가 ]
	회원 가입 시 가입한 이메일 조회를 위해 다음 메서드를 선언합니다.

	public interface UserJpaRepo extends JpaRepository<User, Integer> {
	    Optional<User> findByUid(String email);
	}
	
	
 12) [ 로그인 예외 추가 ]
 
	CEmailSigninFailedException 생성	
	

 13) [ 가입 / 로그인 Controller 추가 ]
 
	로그인 성공 시에는 결과로 Jwt토큰을 발급합니다.
	가입 시에는 패스워드 인코딩을 위해 passwordEncoder설정을 합니다. 
	기본 설정은 bcrypt encoding이 사용됩니다.	
	
	
 14) SpringRestApiApplication에 passwordEncoder bean 추가
 
 15) [ UserController 수정 ]
	유효한 Jwt토큰을 설정해야만 User 리소스를 사용할 수 있도록 Header에 
	X-AUTH-TOKEN을 인자로 받도록 선언합니다.	